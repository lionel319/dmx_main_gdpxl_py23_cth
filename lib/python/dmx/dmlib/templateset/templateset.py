#!/usr/bin/env python
# -*- coding: utf-8 -*-
# Copyright 2011-2013 Altera Corporation. All rights reserved.
# This source code is highly confidential and proprietary information of Altera
# and is to be used for internal Altera purposes only.   Altera assumes no
# responsibility or liability arising out of the application or use of this
# source code for non-Altera purposes.
# $Header: //depot/da/infra/dmx/main_gdpxl_py23_cth/lib/python/dmx/dmlib/templateset/templateset.py#1 $

"""
Templateset produces the root element of the deliverable templateset XML file.
This XML file is the unified database that drives all design data management software.
The templateset contains sub-elements:

* `<alias>` deliverable aliases.  See :py:class:`dmx.dmlib.templateset.alias`.
* `<template>` deliverable templates.  See :py:class:`dmx.dmlib.templateset.template`.
* `<successor>` deliverable predecessor-successor relations.  See :py:class:`dmx.dmlib.templateset.successor`.

Command Line Interface
=======================
`Verifier` is exposed as a command line application as the :doc:`templateset`.

For sample output from `templateset`, see:

* `Sample XML templateset <templateset.xml.txt>`_
* `Human-readable report format <templateset.report.txt>`_.  You can generate \
  even more customized reports using the :doc:`fester`.
* `Report on the readiness of the deliverables <templateset.readiness.txt>`_

The <templateset> Element
=============================
This element contains no text.

This element has the following attributes:

* `version`, the version of this templateset
* `date`, the date that the templateset was created (automatic)
* `author`, the username of the creator (automatic)
"""

__author__ = "John McGehee (jmcgehee@altera.com)"
__revision__ = "$Revision: #1 $"
__date__ = "$Date: 2022/12/13 $"
__copyright__ = "Copyright 2013 Altera Corporation"

import datetime
import getpass
from xml.etree.ElementTree import Comment, Element, SubElement

from dmx.dmlib.templateset.alias import Alias
from dmx.dmlib.templateset.template import Template
from dmx.dmlib.templateset.successor import Successor
from dmx.dmlib.templateset.xmlbase import XmlBase
from dmx.dmlib.dmError import dmError


class Templateset(XmlBase):
    '''Construct a deliverable templateset of the specified name (id) and version.
    You can optionally specify:

    * `aliasNames`, The aliases to output.  The default is to output all aliases.
    * `deliverableNames`, The deliverables to output.  The default is to output all deliverables.
    '''

    #base __init__ not called: pylint: disable = W0231
    def __init__(self, id_, version, aliasNames=None, deliverableNames=None):
        self._id = id_ 
        if not isinstance(version, basestring):
            raise dmError("Deliverable templateset version '{}' is not a string".format(version))
        self._version = version 
        self._date = datetime.date.today()
        self._author = getpass.getuser()

        if aliasNames is not None:
            self._aliasNames = aliasNames
            self._aliasNames.sort()
        else:
            # getNames() returns a sorted list
            self._aliasNames = Alias.getNames()

        if deliverableNames is not None:
            self._deliverableNames = deliverableNames
            self._deliverableNames.sort()
        else:
            self._deliverableNames = Template.getNames()

    @property
    def tagName(self):
        '''The tag name for this XML element.'''
        return 'templateset'
    
    @property
    def reportName(self):
        '''The natural language name for this object for use in reports and messages.'''
        return 'templateset'
    
    @property
    def deliverableNames(self):
        '''The list of deliverable names in this deliverable templateset.'''
        return self._deliverableNames
    
    def element(self, parent=None):
        '''Return an XML ElementTree representing this instance.

        If a `parent` Element is specified, make the ElementTree a SubElement of `parent`.
        However, since `<templateset>` is the root element, it makes little sense to specify
        `parent`.
        
        >>> ts = Templateset('draft', '2.0')
        >>> ts.element().tag
        'templateset'
        '''
        if parent:
            ts = SubElement(parent, self.tagName)
        else:
            ts = Element(self.tagName)
        ts.set('id', self._id)
        ts.set('version', self._version)
        ts.set('date', str(self._date))
        ts.set('author', self._author)
        titleComment = Comment("Altera Data Management templateset\n"
                     "     This file is generated by the `templateset` program.\n"
                     "     See http://sw-web2/tools.ice/icd_cad/dm/{}/doc/templateset.html\n"
                     "\n"
                     "     Altera Confidential and Proprietary.\n"
                     "     Copyright 2013-2014 Altera Corporation.\n".format(self._version))
        ts.append(titleComment)
        
        for deliverableName in self._deliverableNames:
            template = Template(deliverableName)
            template.element(ts)
        for deliverableName in self._deliverableNames:
            successor = Successor(deliverableName)
            successor.element(ts)
        for aliasName in self._aliasNames:
            alias = Alias(aliasName)
            alias.element(ts)
        return ts

    def report(self, ipName='ip1', cellName='ip1'):
        '''Return a human-readable report of this templateset.
        
        >>> ts = Templateset('draft', '2.0')
        >>> ts.report('ipName', 'cellName')      #doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
        "Report on templateset ..."
        '''
        ret = 'Report on {} {}, version {}\n\n'.format(self.reportName, self._id, self._version)
        
        # The method continues after this long explanation string
        ret +='''For other ways to visualize and access the templateset, see:
  http://sw-wiki.altera.com/twiki/bin/view/DesignAutomation/Templateset
  http://sw-wiki.altera.com/twiki/bin/view/DesignAutomation/WhereToPutDesignDataFiles
  
'''
        for deliverableName in self._deliverableNames:
            template = Template(deliverableName)
            ret += template.report(ipName, cellName) + '\n'
        
        for deliverableName in self._deliverableNames:
            successor = Successor(deliverableName)
            ret += successor.report() + '\n'

        for aliasName in self._aliasNames:
            alias = Alias(aliasName)
            ret += alias.report() + '\n'
        
        ret += '\n\n'
        return ret
        
    def reportReadiness(self):
        '''Return a report of how many deliverables in this templateset are ready.
        
        >>> ts = Templateset('draft', '2.0')
        >>> ts.reportReadiness()      #doctest: +ELLIPSIS +NORMALIZE_WHITESPACE
        'Progress report on templateset ...'
        '''
        ret = 'Progress report on templateset {}, version {}\n\n'.format(self._id, self._version)
        
        # The method continues after this long explanation string
        ret += 'This is the report of which deliverables are ready, and not ready.\n'

        # Report aliases
        readyAliases = []
        unreadyAliases = []
        for aliasName in self._aliasNames:
            alias = Alias(aliasName)
            if alias.isReady:
                readyAliases.append(alias)
            else:
                unreadyAliases.append(alias)

        ret +='\n{} design style aliases are ready for action:\n'.format(len(readyAliases))
        ret += '-------------------------------------------------------------\n'
        for alias in readyAliases:
            if alias.caseid :
                ret += '{}, Fogbugz case {}\n'.format(alias.id, alias.caseid )
            else:
                ret += '{}\n'.format(alias.id)
                
        ret +='\n{} design style aliases are NOT ready for action:\n'.format(len(unreadyAliases))
        ret += '-----------------------------------------------------------------\n'
        for alias in unreadyAliases:
            if alias.caseid :
                ret += '{}, Fogbugz case {}\n'.format(alias.id, alias.caseid )
            else:
                ret += '{}\n'.format(alias.id)
        
        # Report deliverables
        readyTemplates = []
        unreadyTemplates = []
        for deliverableName in self._deliverableNames:
            template = Template(deliverableName)
            if template.isReady:
                readyTemplates.append(template)
            else:
                unreadyTemplates.append(template)

        ret += '\n{} templates are ready for action:\n'.format(len(readyTemplates))
        ret += '------------------------------------\n'
        for template in readyTemplates:
            if template.caseid :
                ret += '{}, Fogbugz case {}\n'.format(template.id_, template.caseid )
            else:
                ret += '{}\n'.format(template.id_)
                
        ret +='\n{} templates are NOT ready for action:\n'.format(len(unreadyTemplates))
        ret += '---------------------------------------\n'
        for template in unreadyTemplates:
            if template.caseid :
                ret += '{}, Fogbugz case {}\n'.format(template.id_, template.caseid )
            else:
                ret += '{}\n'.format(template.id_)
                
        ret += '\n\n'
        
        # Report successors
        readySuccessors = []
        unreadySuccessors = []
        for deliverableName in self._deliverableNames:
            successor = Successor(deliverableName)
            if successor.isReady:
                readySuccessors.append(successor)
            else:
                unreadySuccessors.append(successor)

        ret +='\n{} predecessor-successor relationships are ready for action:\n'.format(len(readySuccessors))
        ret += '-------------------------------------------------------------\n'
        for successor in readySuccessors:
            if successor.caseid :
                ret += '{}, Fogbugz case {}\n'.format(successor.id, successor.caseid )
            else:
                ret += '{}\n'.format(successor.id)

        ret +='\n{} predecessor-successor relationships are NOT ready for action:\n'.format(len(unreadySuccessors))
        ret += '-----------------------------------------------------------------\n'
        for successor in unreadySuccessors:
            if successor.caseid :
                ret += '{}, Fogbugz case {}\n'.format(successor.id, successor.caseid )
            else:
                ret += '{}\n'.format(successor.id)

        return ret


if __name__ == "__main__":
    # Running DeliverableFTemplateSet_test.py is the preferred test method,
    # but run doctest alone if the user requests.
    import doctest
    doctest.testmod()
